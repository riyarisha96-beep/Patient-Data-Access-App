import json
import os
from pathlib import Path
from dotenv import load_dotenv
from web3 import Web3
import streamlit as st

st.set_page_config(page_title="Patient Data Access DApp", layout="centered")

# Load environment
load_dotenv()
DEFAULT_RPC = os.getenv("RPC_URL", "http://127.0.0.1:8545")
PRIVATE_KEY = os.getenv("PRIVATE_KEY", "")

# Load contract info generated by Hardhat deploy script
artifact_path = Path(__file__).parent / "contract-info.json"
if not artifact_path.exists():
    st.error("contract-info.json not found. Run the Hardhat deploy script to generate it.")
    st.stop()

contract_info = json.loads(artifact_path.read_text())
CONTRACT_ADDRESS = Web3.to_checksum_address(contract_info["address"])
ABI = contract_info["abi"]

# Sidebar connection settings
st.sidebar.header("Connection")
rpc_url = st.sidebar.text_input("RPC URL", value=DEFAULT_RPC)
pk_input = st.sidebar.text_input("Private Key", type="password", value=PRIVATE_KEY)
connect_btn = st.sidebar.button("Connect")

if "w3" not in st.session_state or connect_btn:
    st.session_state.w3 = Web3(Web3.HTTPProvider(rpc_url))
    if not st.session_state.w3.is_connected():
        st.error("Web3 connection failed. Is Hardhat node running?")
    else:
        st.success("Connected to chain ‚úì")

w3 = st.session_state.get("w3", None)
if w3 is None or not w3.is_connected():
    st.stop()

chain_id = w3.eth.chain_id
st.caption(f"Connected chainId: {chain_id}")

st.title("üè• Patient Data Access (Blockchain)")
st.write("Contract address:", f"`{CONTRACT_ADDRESS}`")

# Prepare contract
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=ABI)

# Account setup
acct = None
if pk_input:
    try:
        acct = w3.eth.account.from_key(pk_input.strip())
        st.success(f"Loaded account: {acct.address}")
    except Exception as e:
        st.error(f"Invalid private key: {e}")

if acct is None:
    st.warning("Provide a private key from your Hardhat node to send transactions.")

def send_tx(tx_func):
    if acct is None:
        st.error("No account loaded. Add PRIVATE_KEY in .env or sidebar.")
        return None
    try:
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = tx_func.build_transaction({
            "from": acct.address,
            "nonce": nonce,
            "gasPrice": w3.eth.gas_price,
            "chainId": w3.eth.chain_id
        })
        # Estimate gas
        gas = w3.eth.estimate_gas(tx)
        tx["gas"] = int(gas * 1.2)
        signed = acct.sign_transaction(tx)
        tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)
        receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        return receipt
    except Exception as e:
        st.error(f"Transaction failed: {e}")
        return None

st.subheader("Grant / Revoke Access (Patient)")
with st.form("grant_revoke"):
    provider = st.text_input("Provider address (0x...)", "")
    data_type = st.text_input("Data type label (e.g., 'EHR', 'Lab', 'Imaging')", "EHR")
    col1, col2 = st.columns(2)
    with col1:
        grant = st.form_submit_button("Grant Access")
    with col2:
        revoke = st.form_submit_button("Revoke Access")

    if grant and provider:
        receipt = send_tx(contract.functions.grantAccess(Web3.to_checksum_address(provider), data_type))
        if receipt:
            st.success(f"Granted access for '{data_type}' to {provider}. Tx: {receipt.transactionHash.hex()}")

    if revoke and provider:
        receipt = send_tx(contract.functions.revokeAccess(Web3.to_checksum_address(provider), data_type))
        if receipt:
            st.success(f"Revoked access for '{data_type}' from {provider}. Tx: {receipt.transactionHash.hex()}")

st.subheader("Check Access (Anyone)")
with st.form("check_access"):
    provider_check = st.text_input("Provider address to check", "")
    data_type_check = st.text_input("Data type label", "EHR")
    check = st.form_submit_button("Check")
    if check and provider_check:
        try:
            allowed = contract.functions.checkAccess(Web3.to_checksum_address(provider_check), data_type_check).call()
            st.info(f"Allowed? **{allowed}**")
        except Exception as e:
            st.error(f"Check failed: {e}")

st.subheader("Log Data Access (Provider)")
with st.form("log_access"):
    data_type_log = st.text_input("Data type label", "EHR")
    purpose = st.text_input("Purpose (e.g., 'diagnosis', 'follow-up')", "diagnosis")
    log_btn = st.form_submit_button("Log Access")
    if log_btn:
        receipt = send_tx(contract.functions.logAccess(data_type_log, purpose))
        if receipt:
            st.success(f"Logged access. Tx: {receipt.transactionHash.hex()}")

st.subheader("Recent Access Events")
try:
    # Fetch events (may be many; keep it small)
    latest = w3.eth.block_number
    from_block = max(0, latest - 2000)
    logs = contract.events.DataAccessed().get_logs(fromBlock=from_block, toBlock="latest")
    if not logs:
        st.caption("No DataAccessed events yet.")
    else:
        for ev in reversed(logs[-20:]):  # show up to 20 latest
            args = ev["args"]
            provider_addr = args["provider"]
            data_type_hash = args["dataType"]
            purpose_val = args["purpose"]
            st.write(f"‚Ä¢ **Provider:** `{provider_addr}` | **DataTypeHash:** `{data_type_hash.hex()}` | **Purpose:** `{purpose_val}` | **Block:** {ev['blockNumber']}")
except Exception as e:
    st.warning(f"Could not load events: {e}")
